### 试对比或说明CommonJS规范，AMD规范，CMD规范，ES6 Module

1. CommonJS规范

- JS模块化开发的标准，目前对应的实现是：NodeJs
- 主要针对服务端，文件都在本地，同步导入即使卡住主线程影响也不大
- 支持动态导入，也就是 require(${path}/xx.js), 在运行时确定模块依赖关系
- 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次

2. AMD规范

- JS模块化开发的标准，目前对应的实现是：RequireJs
- 主要针对浏览器端
- 都是并行加载js文件, AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）
- AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。
- AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。

3. CMD规范

- JS模块化开发的标准，目前对应的实现是：SeaJs
- 主要针对浏览器端
- 都是并行加载js文件, CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。
- CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。
- CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。

4. ES6 Module
- 不支持require动态导入
- 主要针对浏览器端，异步导入，因为用于浏览器，需要下载文件
- 实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化

* 服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行。这里如果有其他后端语言，如java，经验的‘玩家’应该更容易理解
* 浏览器端要保证效率，需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好
